** This testcase demonstrates the syntactic correctness of the constructs such as modules, simple and declaration statements, and expressions**

declare module compute;
<<<driver program>>>
start
	declare var_1_, var_2_, var_3_:integer;
	declare R1_abc: boolean;
	declare r2_ABC: integer;
	declare R3_abc: real;
	declare sum: integer;
	get_value(var_1_);
	var_1_ := 2;

	switch(R1_abc)
	start
	case true: declare index:integer;
			print(index);
			sum:=1;
			break;
	case false: print(sum);
			declare A:array[1..15] of real;
			declare index:integer;
			print(index);
			**prints the values of sum and index  15-n times**
			break;

	end

	while(var_1_ < 3)
	start
	get_value(tempvar);
	**arr1[i]:=tempvar;** 		
	declare B:array[-1..+10] of boolean;
	**tempvar:=-(tempvar+ arr1[k]+arr1[+5]-arr1[-10]);**
	**B[k]:=-10;**
	var_1_:=var_1_+1;
	print(var_1_);
	** the semantics of while needs an increment and will be taken care of at the second phase**
	end

	for(index in -1..15)
	start	
		var_1_ := var_1_ + 1;
		print(var_1_);
	end
	print(20);
	**get_value(var_1_);

	var_2_:=var_1_;
	var_3_:= -(6);**
	[R1_abc, r2_ABC, R3_abc] := use module compute with parameters var_1_, var_2_, var_3;
	var_3_:= -(6);
	**[R1_abc, r2_ABC, R3_abc] := use module compute with parameters var_1_, var_2_, var_34;**
	** do not bother that the last variable is not declared. It will be taken care of later in the semantic analysis phase**
end
<<module compute>>
takes input[a:integer, b:integer, c:integer];
returns [res_1:boolean, res_2_a:integer, res_2__b:real];
start
	declare b:integer;
	declare f:boolean;
	res_2_a:= -(a*b-c+5);
	declare A:array[1..15] of integer;
	b  :=A[a*b+c] ;

	**f := a <=  b AND c >= a OR  a<0 AND false;**

	** check  rules 27 a to e and redefine to preserve the parentheses needs ** 
	print(res_1);
end

**verify the output of the lexical analyzer as well**
**check the correctness of the parse tree**